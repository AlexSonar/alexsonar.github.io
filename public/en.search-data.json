{"/about/":{"data":{"":"","experiences--qualifications#Experiences \u0026amp; Qualifications":"Introduction Hi every one! My name is Alex Sonar. Belong to the tech-society, I also found GitHub such a lovely place for my professional and creative focus. I am often impressed by so talented teams, and their useful projects.\nThis inspired me to create this blog and share some of my work, my opinions or some my vision. I found important the mission, to share my expertise to other as well.\nPlease feel free to get in touch with me.\nExpertise (current focused expertise) Business consulting in deep-tech fields, with targets: tech- strategy valuations / validation, effectiveness, optimisation. Data Science and Analytics. Researches in Code Analysis Techniques. Code Analysis with AI sysctems. Software Design. Experiences \u0026 Qualifications Career in software development 22 years. Certified Solution Architect. ","expertise-current-focused-expertise#Expertise (current focused expertise)":"","introduction#Introduction":"","passion-and-purpose#Passion and purpose":" My passion is to discover on a deep level necessary in-tech challenges for a business and understand their perspectives. I‚Äôm writing about topic according mentioned expertise and sharing my personal connection or motivation behind with interest in the subjects.","why-it-matters#Why it matters?!":"Through shared discovery, our readers and I can benefit. We can gain collaborative value by solving problems and tech puzzles. I hope it might be helpful to many of our readers in focus on tech topics or the business strategy planning.\nPlease join participate by leaving comments in the post threads. feel free to ask questions and join our discussion. "},"title":"Alex Sonar"},"/blog/":{"data":{"":" RSS Feed "},"title":"Blog"},"/blog/asembly/":{"data":{"":"Percentage of page loads over time The chart below shows the percentage of page loads (in Chrome) that use this feature at least once. Data is across all channels and platforms. Newly added use counters that are not on Chrome stable yet only have data from the Chrome channels they‚Äôre on.\nWith many of the core WebAssembly features now cross browser and more advanced features joining the list like exception handling, tail calls, and garbage collection, I think we‚Äôre going to see more languages target WebAssembly and existing tooling improve.\nWebAssembly is still a small amount at around 2% of Chrome users, but there has been a steady increase in its use on the web. Even at 2%, that‚Äôs still a pretty big amount given the size of the web. Sourcre: chromestatus\u003emetrics\u003etimeline\u003eweassembly"},"title":"asembly"},"/blog/n/":{"data":{"":"The hardest part of building software is not coding, it‚Äôs requirements\nWhy replacing programmers with AI won‚Äôt be so easy.\nData-driven developers often face challenges related to defining and understanding requirements for their software projects. While coding is an important aspect of software development, the real difficulties typically arise from determining what the software should do and how it should behave\n.\nChallenges in Defining and Understanding Requirements\nAmbiguity: Requirements can be vague or open to interpretation, leading to misunderstandings and potential errors in the final product. Changing Requirements: Requirements may change over time due to evolving business needs or new insights gained during the development process. Adapting to these changes can be challenging. Incomplete or Inconsistent Requirements: Inadequate or inconsistent requirements can lead to gaps in functionality or conflicting expectations. Lack of Domain Knowledge: Developers may face difficulties understanding the domain-specific concepts and terminology required to accurately capture requirements. Communication Issues: Effective communication between developers, stakeholders, and end-users is crucial for understanding and documenting requirements. Miscommunication can lead to misunderstandings and misaligned expectations. Addressing the Challenges\nTo address these challenges, data-driven developers can employ various strategies:\nCollaboration and Communication: Foster open and frequent communication with stakeholders and end-users to clarify requirements and ensure a shared understanding. Iterative Development: Adopt an iterative development approach, such as Agile or Scrum, which allows for continuous feedback and adaptation to changing requirements. User Stories and Use Cases: Utilize user stories and use cases to capture requirements in a more structured and user-centric manner. Prototyping and Mockups: Create prototypes or mockups to visualize and validate requirements before starting the development process. Domain Expertise: Seek domain experts' input to gain a deeper understanding of the problem domain and ensure accurate requirement gathering. Requirements Documentation: Maintain clear and up-to-date documentation of requirements to serve as a reference throughout the development process. By addressing these challenges and employing effective strategies, data-driven developers can enhance their ability to define and understand requirements, leading to more successful software development projects."},"title":"n"},"/showcase/":{"data":{"":"Publics stories \u0026 analyses.\nOpen source projects powered by Hextra. Porter LutheranConfessions Hextra Starter Template "},"title":"Showcase"},"/technologies/":{"data":{"":"üëã Hello! Welcome to the Hextra documentation!","features#Features":" Beautiful Design - Inspired by Nextra, Hextra utilizes Tailwind CSS to offer a modern design that makes your site look outstanding. Responsive Layout and Dark Mode - It looks great on all devices, from mobile, tablet to desktop. Dark mode is also supported to accommodate various lighting conditions. Fast and Lightweight - Powered by Hugo, a lightning-fast static-site generator housed in a single binary file, Hextra keeps its footprint minimal. No JavaScript or Node.js are needed to use it. Full-text Search - Built-in offline full-text search powered by FlexSearch, no additional configuration required. Battery-included - Markdown, syntax highlighting, LaTeX math formulae, diagrams and Shortcodes elements to enhance your content. Table of contents, breadcrumbs, pagination, sidebar navigation and more are all automatically generated. Multi-language and SEO Ready - Multi-language sites made easy with Hugo‚Äôs multilingual mode. Out-of-the-box support is included for SEO tags, Open Graph, and Twitter Cards. ","next#Next":"Dive right into the following section to get started:\nGetting StartedLearn how to create website using Hextra ","questions-or-feedback#Questions or Feedback?":" ‚ùì Hextra is still in active development. Have a question or feedback? Feel free to open an issue! ","what-is-hextra#What is Hextra?":"Hextra is a modern, fast and batteries-included [Hugo][hugo] theme built with [Tailwind CSS][tailwind-css].\nDesigned for building beautiful websites for documentation, blogs, and websites, it provides out-of-the-box features and flexibility to meet various requirements."},"title":"Documentation"},"/technologies/modern-computing/":{"data":{"":"Modern computing\nRH OpenShift Configuration WebAssembly (Wasm) Syntax Highlighting LaTeX Diagrams Shortcodes Deploy Site "},"title":"Modern computing"},"/technologies/modern-computing/openshift/":{"data":{"":"Hugo generates static websites, allowing for flexible hosting options. This page provides guides for deploying your Hextra site on various platforms.","cloudflare-pages#Cloudflare Pages":" Put your site source code in a Git repository (e.g. GitHub) Log in to the Cloudflare dashboard and select your account In Account Home, select Workers \u0026 Pages \u003e Create application \u003e Pages \u003e Connect to Git Select the repository, and in the Set up builds and deployments section, provide the following information: Configuration Value Production branch main Build command hugo --gc --minify Build directory public For more details, check out:\nDeploy a Hugo site. Language support and tools. ","github-pages#GitHub Pages":"GitHub Pages is the recommended way to deploy and host your website for free.\nIf you bootstrap the site using hextra-starter-template, it has provided GitHub Actions workflow out-of-the-box that helps automatically deploy to GitHub Pages.\nGitHub Actions Configuration Below is an example configuration from hextra-starter-template:\n.github/workflows/pages.yaml# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\"main\"] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \"pages\" cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.117.0 steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Go uses: actions/setup-go@v4 with: go-version: '1.21' - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.117.0' extended: true - name: Build with Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --gc --minify \\ --baseURL \"https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/\" - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v2 In your repository settings, set the Pages \u003e Build and deployment \u003e Source to GitHub Actions: By default, the above GitHub Actions workflow .github/workflows/pages.yaml assumes that the site is deploying to https://\u003cUSERNAME\u003e.github.io/\u003cREPO\u003e/.\nIf you are deploying to https://\u003cUSERNAME\u003e.github.io/ then modify the --baseURL:\n.github/workflows/pages.yaml 54 55 56 57 run: | hugo \\ --gc --minify \\ --baseURL \"https://${{ github.repository_owner }}.github.io/\" If you are deploying to your own domain, please change the --baseURL value accordingly.","netlify#Netlify":" Push your code to your Git repository (GitHub, GitLab, etc.) Import the project to Netlify If you are not using [hextra-starter-template][hextra-starter-template], configure the following manually: Configure the Build command to hugo --gc --minify Specify the Publish directory to public Add Environment variable HUGO_VERSION and set to 0.119.0 Deploy! Check Hugo on Netlify for more details.","vercel#Vercel":" Push your code to your Git repository (GitHub, GitLab, etc.) Go to Vercel Dashboard and import your Hugo project Configure the project, select Hugo as Framework Preset Override the Build Command and Install command: Set Build Command to hugo --gc --minify Set Install Command to yum install golang "},"title":"Openshift"},"/technologies/modern-computing/tools_2_compare/":{"data":{"":"https://devbase.fyi/\nHelp organisations Reach nex level of transformation and productivity"},"title":"tools_2_compare"},"/technologies/modern-computing/webassembly/":{"data":{"":"","#":"Objectives:\nWasm is a technology that designed to enable near-native code execution in the web browser also it has Implementations as component composition represented in the portable code with low level binary web-comatible format, also a modern computer programming language for the web. Mine goals is unfication of software execuion. In concept of assembly from many languages.\nThe file size generated is small it loads and executes faster. easily run in modern web browsers. binary format and it can run on the web just like javascript.\nstandardized bytecode format for executing programs.\nHistory WebAssembly Designed by\tW3C was first announced in 2015 Based on Structured programming. Programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.\nIn opposit many system-dependent machine code representation technlogies (f.e JIT) where resulting binary file can execute natively only. Wasm migh be refered to intermediate representation AOT system-independent. why it called near-native In computer science, ahead-of-time (AOT) compilation often mean the act of compiling an higher-level into an lower-level programming language before execution of a program, usually at build-time, to reduce the amount of work needed to be performed at run time.\nFilename extensions\n.wat (text format) .wasm (binary format)\nRelated non-browser implementations for general-purpose use: Wasmtime or WAMR, wasm3, WAVM, and many others.\nClose designed technology is asm.js already provides near-native code execution\nAdvantages of WebAssembly\nWebAssembly (Wasm) offers several advantages that make it a powerful technology for web development. Here are some key benefits of WebAssembly:\nWide Language Support: WebAssembly supports multiple programming languages, including C, C++, Rust, and Go. This allows developers to leverage their existing knowledge and codebase in these languages and compile them to WebAssembly for execution in web browsers .\nCompact Size: WebAssembly code is highly compact, which means it loads and executes faster compared to traditional web technologies. The small size of WebAssembly files contributes to improved performance and reduced latency\n.\nHigh Performance: WebAssembly is designed to execute at near-native speed, thanks to its low-level binary format. It takes advantage of common hardware capabilities, allowing for efficient execution across different platforms\n.\nUniversal Support: WebAssembly is supported by all major web browsers, making it a universal technology that can run seamlessly across different platforms and devices.\nSafety and Security: WebAssembly provides a sandboxed execution environment, ensuring that code running in the browser is isolated and cannot access sensitive resources or compromise the security of the user‚Äôs system\n.\nHardware Independence: WebAssembly is hardware-independent, meaning it can run on various architectures and devices without requiring modifications. This portability makes it easier to develop applications that can reach a wide audience.\nInteroperability: WebAssembly can be easily integrated with existing web applications. It can coexist with JavaScript, allowing developers to combine the strengths of both technologies. WebAssembly modules can be imported into web or Node.js apps, and WebAssembly functions can be accessed and used via JavaScript\n.\nEase of Debugging: Although WebAssembly is a low-level assembly language, it also has a human-readable text format. This format allows developers to write, view, and debug WebAssembly code more easily\n.\nServer-Side Execution: WebAssembly is not limited to client-side execution. It can also run on the server side, providing benefits such as faster cold start times compared to Docker containers\n. These advantages make WebAssembly a compelling choice for developers looking to enhance the performance, portability, and security of their web applications.\nPlease let me know if you have any further questions!\nDisadvantages of WebAssembly\nWhile WebAssembly (Wasm) offers numerous advantages, it also has some limitations and disadvantages. Here are a few of them:\nLack of Garbage Collection: One of the notable disadvantages of WebAssembly is the absence of built-in garbage collection for automatic memory management. However, there are plans to add garbage collection in the future .\nToolchain Requirement: WebAssembly requires a toolchain for compilation. This means developers need a compiler and a compiler step to generate WebAssembly code. While this is not a major hurdle, it adds an extra step to the development process\n.\nDependency on JavaScript: WebAssembly relies on JavaScript to interact with the Document Object Model (DOM) and access other web functionality. Although WebAssembly can extend the capabilities of JavaScript, it still needs to interface through JavaScript to access certain web APIs\n.\nLimited API Access: WebAssembly has limited access to certain APIs compared to JavaScript. While efforts are being made to expand the API support for WebAssembly, there are still some restrictions on direct access to the DOM and other web APIs.\nLimited Browser Support: Although major web browsers support WebAssembly, older browsers may not have full compatibility. This can limit the reach of WebAssembly-based applications, especially in environments where older browsers are still in use.\nBundle Size: WebAssembly code can contribute to larger bundle sizes compared to traditional web technologies. While WebAssembly itself is compact, the additional JavaScript code required for interaction and functionality can increase the overall size of the application\n. Early Stage of Development: WebAssembly is still a relatively new technology, and its future is still being shaped. As with any emerging technology, there may be uncertainties and evolving best practices that developers need to adapt to. Despite these limitations, WebAssembly continues to evolve and improve, and its advantages often outweigh the disadvantages for many use cases. It offers significant performance benefits and opens up new possibilities for web development.\nIf you have any more questions, feel free to ask!","disadvantages#Disadvantages":"Some browsers or their settings don‚Äôt support WebAssembly or have it disabled for security reasons.\nIn terms of usefulness of this technology unfortunately it often shows weak return.\nbut ways to bring garbage collected programming languages efficiently to WebAssembly\nDue to the displacement of the costly parts Towards traffic service and static data desribution contracts with CDN leads to hi costs low latency of CDN\nBinaryen is a compiler and toolchain infrastructure library for WebAssembly https://github.com/WebAssembly/binaryen Awesome Wasm https://github.com/mbasso/awesome-wasm Collection of awesome things regarding WebAssembly (wasm) ecosystem.\nhttps://mbebenita.github.io/WasmExplorer/\n- Hugo Modules - wowchemy - wowchemy-plugins-netlify - wowchemy-plugins-netlify-cms - wowchemy-plugins-reveal "},"title":"WebAssembly aka (Wasm)"},"/technologies/modern-computing/webcontainers/":{"data":{"":"https://blog.stackblitz.com/posts/webcontainers-are-now-supported-on-firefox/\nhttps://stackblitz.com/github/withastro/astro/tree/latest/examples/portfolio?file=src%2Fpages%2Findex.astro\nhttps://zzmimjlpzgithub-1z1l--4321--5a198b5c.local-corp.webcontainer.io"},"title":"WebContainers"}}